/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ApiClientBase {

  constructor() {}

  protected transformOptions( options: any ) {
    if ( options && options.headers ) {
      options.headers = ( <Headers>options.headers ).set( 'Authorization', 'TEST' );
    }

    return Promise.resolve( options );
  }

}

@Injectable()
export class AuthService extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    register(userCredentialsDTO: UserCredentialsDTO): Observable<ApiResponseOfLoginResponse> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userCredentialsDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfLoginResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfLoginResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ApiResponseOfLoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfLoginResponse>(<any>null);
    }

    login(userCredentialsDTO: UserCredentialsDTO): Observable<ApiResponseOfLoginResponse> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userCredentialsDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfLoginResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfLoginResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApiResponseOfLoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfLoginResponse>(<any>null);
    }
}

@Injectable()
export class ProfilesService extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets the requested user profile.
      Sending -1 as the id, gets the current authenticated user.
    
    
    
      GET: [controller-route]/69
     */
    get(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/profiles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Updates the complete profile of the current authenticated user.
    
    
    
      PUT: [controller-route]
     */
    put(): Observable<void> {
        let url_ = this.baseUrl + "/api/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Deletes the profile of the current authenticated user.
    
    
    
      DELETE: [controller-route]
     */
    delete(): Observable<void> {
        let url_ = this.baseUrl + "/api/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ShoutsService extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets top shouts paginated.
                
    ?filterBy=1 amp; lastId=0 amp; limit=10
     * @param filterBy (optional) 
     * @param lastId (optional) 
     * @param limit (optional) 
     */
    get(filterBy?: FilterType | undefined, lastId?: number | undefined, limit?: number | undefined): Observable<ApiResponseOfListOfShout> {
        let url_ = this.baseUrl + "/api/shouts?";
        if (filterBy === null)
            throw new Error("The parameter 'filterBy' cannot be null.");
        else if (filterBy !== undefined)
            url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&"; 
        if (lastId === null)
            throw new Error("The parameter 'lastId' cannot be null.");
        else if (lastId !== undefined)
            url_ += "lastId=" + encodeURIComponent("" + lastId) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfListOfShout>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfListOfShout>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApiResponseOfListOfShout> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfListOfShout.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfListOfShout>(<any>null);
    }

    post(newShoutDTO: NewShoutDTO): Observable<ApiResponseOfCreateShoutResult> {
        let url_ = this.baseUrl + "/api/shouts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newShoutDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateShoutResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateShoutResult>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<ApiResponseOfCreateShoutResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateShoutResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateShoutResult>(<any>null);
    }

    /**
     * Gets a specific shout by id.
     */
    getById(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/shouts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    /**
     * Gets all shouts paginated of a specific user id. 
    If the user is -1, it defaults to the current user in session. 
    GET: " user/{userId} ? lastId={lastId::0} & limit={limit::10} "
     * @param lastId (optional) 
     * @param limit (optional) 
     */
    getByUserId(userId: number, lastId?: number | undefined, limit?: number | undefined): Observable<ApiResponseOfListOfShout> {
        let url_ = this.baseUrl + "/api/shouts/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (lastId === null)
            throw new Error("The parameter 'lastId' cannot be null.");
        else if (lastId !== undefined)
            url_ += "lastId=" + encodeURIComponent("" + lastId) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfListOfShout>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfListOfShout>><any>_observableThrow(response_);
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<ApiResponseOfListOfShout> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfListOfShout.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfListOfShout>(<any>null);
    }

    getComments(shoutId: number, lastId?: number | undefined, limit?: number | undefined): Observable<ApiResponseOfListOfComment> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments?";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        if (lastId === null)
            throw new Error("The parameter 'lastId' cannot be null.");
        else if (lastId !== undefined)
            url_ += "lastId=" + encodeURIComponent("" + lastId) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfListOfComment>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfListOfComment>><any>_observableThrow(response_);
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<ApiResponseOfListOfComment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfListOfComment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfListOfComment>(<any>null);
    }

    postComment(shoutId: number, newCommentDTO: NewCommentDTO): Observable<ApiResponseOfCreateCommentResult> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCommentDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostComment(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateCommentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateCommentResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostComment(response: HttpResponseBase): Observable<ApiResponseOfCreateCommentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateCommentResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateCommentResult>(<any>null);
    }

    postLike(shoutId: number): Observable<ApiResponseOfCreateReactionResult> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/likes";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostLike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostLike(response: HttpResponseBase): Observable<ApiResponseOfCreateReactionResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateReactionResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateReactionResult>(<any>null);
    }

    deleteShoutLike(shoutId: number): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/likes";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteShoutLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShoutLike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShoutLike(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }

    postDislike(shoutId: number): Observable<ApiResponseOfCreateReactionResult> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/dislikes";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostDislike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDislike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostDislike(response: HttpResponseBase): Observable<ApiResponseOfCreateReactionResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateReactionResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateReactionResult>(<any>null);
    }

    deleteShoutDislike(shoutId: number): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/dislikes";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteShoutDislike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShoutDislike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShoutDislike(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }

    postCommentLike(commentId: number, shoutId: string): Observable<ApiResponseOfCreateReactionResult> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments/{commentId}/likes";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCommentLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCommentLike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostCommentLike(response: HttpResponseBase): Observable<ApiResponseOfCreateReactionResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateReactionResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateReactionResult>(<any>null);
    }

    deleteCommentLike(commentId: number, shoutId: string): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments/{commentId}/likes";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCommentLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCommentLike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCommentLike(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }

    postCommentDislike(commentId: number, shoutId: string): Observable<ApiResponseOfCreateReactionResult> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments/{commentId}/dislikes";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCommentDislike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCommentDislike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfCreateReactionResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostCommentDislike(response: HttpResponseBase): Observable<ApiResponseOfCreateReactionResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateReactionResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfCreateReactionResult>(<any>null);
    }

    deleteCommentDislike(commentId: number, shoutId: string): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments/{commentId}/dislikes";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCommentDislike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCommentDislike(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCommentDislike(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }

    delete(shoutId: number): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}";
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }

    deleteComment(commentId: number, shoutId: string): Observable<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/shouts/{shoutId}/comments/{commentId}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        if (shoutId === undefined || shoutId === null)
            throw new Error("The parameter 'shoutId' must be defined.");
        url_ = url_.replace("{shoutId}", encodeURIComponent("" + shoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(<any>response_);
                } catch (e) {
                    return <Observable<ApiResponseOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResponseOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<ApiResponseOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponseOfBoolean>(<any>null);
    }
}

export class ApiResponseOfLoginResponse implements IApiResponseOfLoginResponse {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: LoginResponse | undefined;

    constructor(data?: IApiResponseOfLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.endpointResult = _data["endpointResult"] ? LoginResponse.fromJS(_data["endpointResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResponseOfLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["endpointResult"] = this.endpointResult ? this.endpointResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApiResponseOfLoginResponse {
    error: boolean;
    message?: string | undefined;
    endpointResult?: LoginResponse | undefined;
}

export class LoginResponse implements ILoginResponse {
    jwt?: string | undefined;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jwt = _data["jwt"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jwt"] = this.jwt;
        return data; 
    }
}

export interface ILoginResponse {
    jwt?: string | undefined;
}

export class UserCredentialsDTO implements IUserCredentialsDTO {
    email!: string;
    password!: string;

    constructor(data?: IUserCredentialsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserCredentialsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUserCredentialsDTO {
    email: string;
    password: string;
}

export class ApiResponseOfListOfShout implements IApiResponseOfListOfShout {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: Shout[] | undefined;

    constructor(data?: IApiResponseOfListOfShout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            if (Array.isArray(_data["endpointResult"])) {
                this.endpointResult = [] as any;
                for (let item of _data["endpointResult"])
                    this.endpointResult!.push(Shout.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfListOfShout {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfListOfShout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        if (Array.isArray(this.endpointResult)) {
            data["endpointResult"] = [];
            for (let item of this.endpointResult)
                data["endpointResult"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApiResponseOfListOfShout {
    error: boolean;
    message?: string | undefined;
    endpointResult?: Shout[] | undefined;
}

export class NewShoutDTO implements INewShoutDTO {
    userId!: number;
    content?: string | undefined;

    constructor(data?: INewShoutDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): NewShoutDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NewShoutDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["content"] = this.content;
        return data; 
    }
}

export interface INewShoutDTO {
    userId: number;
    content?: string | undefined;
}

export class Shout extends NewShoutDTO implements IShout {
    id!: number;
    userName?: string | undefined;
    createDate!: Date;
    likesCount!: number;
    dislikesCount!: number;
    assets?: ShoutAsset[] | undefined;

    constructor(data?: IShout) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.likesCount = _data["likesCount"];
            this.dislikesCount = _data["dislikesCount"];
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(ShoutAsset.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Shout {
        data = typeof data === 'object' ? data : {};
        let result = new Shout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["likesCount"] = this.likesCount;
        data["dislikesCount"] = this.dislikesCount;
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IShout extends INewShoutDTO {
    id: number;
    userName?: string | undefined;
    createDate: Date;
    likesCount: number;
    dislikesCount: number;
    assets?: ShoutAsset[] | undefined;
}

export class ShoutAsset implements IShoutAsset {
    id!: number;
    shoutId!: number;
    assetTypeId!: number;
    url?: string | undefined;

    constructor(data?: IShoutAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shoutId = _data["shoutId"];
            this.assetTypeId = _data["assetTypeId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ShoutAsset {
        data = typeof data === 'object' ? data : {};
        let result = new ShoutAsset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shoutId"] = this.shoutId;
        data["assetTypeId"] = this.assetTypeId;
        data["url"] = this.url;
        return data; 
    }
}

export interface IShoutAsset {
    id: number;
    shoutId: number;
    assetTypeId: number;
    url?: string | undefined;
}

export enum FilterType {
    Top = 1,
    MostComments = 2,
    Last = 3,
}

export class ApiResponseOfListOfComment implements IApiResponseOfListOfComment {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: Comment[] | undefined;

    constructor(data?: IApiResponseOfListOfComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            if (Array.isArray(_data["endpointResult"])) {
                this.endpointResult = [] as any;
                for (let item of _data["endpointResult"])
                    this.endpointResult!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResponseOfListOfComment {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfListOfComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        if (Array.isArray(this.endpointResult)) {
            data["endpointResult"] = [];
            for (let item of this.endpointResult)
                data["endpointResult"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApiResponseOfListOfComment {
    error: boolean;
    message?: string | undefined;
    endpointResult?: Comment[] | undefined;
}

export class NewCommentDTO implements INewCommentDTO {
    content?: string | undefined;

    constructor(data?: INewCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): NewCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NewCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

export interface INewCommentDTO {
    content?: string | undefined;
}

export class Comment extends NewCommentDTO implements IComment {
    id!: number;
    shoutId!: number;
    userId!: number;
    createDate!: Date;
    likesCount!: number;
    dislikesCount!: number;

    constructor(data?: IComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.shoutId = _data["shoutId"];
            this.userId = _data["userId"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.likesCount = _data["likesCount"];
            this.dislikesCount = _data["dislikesCount"];
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shoutId"] = this.shoutId;
        data["userId"] = this.userId;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["likesCount"] = this.likesCount;
        data["dislikesCount"] = this.dislikesCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IComment extends INewCommentDTO {
    id: number;
    shoutId: number;
    userId: number;
    createDate: Date;
    likesCount: number;
    dislikesCount: number;
}

export class ApiResponseOfCreateShoutResult implements IApiResponseOfCreateShoutResult {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: CreateShoutResult | undefined;

    constructor(data?: IApiResponseOfCreateShoutResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.endpointResult = _data["endpointResult"] ? CreateShoutResult.fromJS(_data["endpointResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResponseOfCreateShoutResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCreateShoutResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["endpointResult"] = this.endpointResult ? this.endpointResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApiResponseOfCreateShoutResult {
    error: boolean;
    message?: string | undefined;
    endpointResult?: CreateShoutResult | undefined;
}

export class CreateShoutResult implements ICreateShoutResult {
    state!: CreateShoutState;
    newShout?: Shout | undefined;

    constructor(data?: ICreateShoutResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.newShout = _data["newShout"] ? Shout.fromJS(_data["newShout"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateShoutResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShoutResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["newShout"] = this.newShout ? this.newShout.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateShoutResult {
    state: CreateShoutState;
    newShout?: Shout | undefined;
}

export enum CreateShoutState {
    Success = 0,
    ContentTooLong = 1,
    ContentTooSmall = 2,
}

export class ApiResponseOfCreateReactionResult implements IApiResponseOfCreateReactionResult {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: CreateReactionResult | undefined;

    constructor(data?: IApiResponseOfCreateReactionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.endpointResult = _data["endpointResult"] ? CreateReactionResult.fromJS(_data["endpointResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResponseOfCreateReactionResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCreateReactionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["endpointResult"] = this.endpointResult ? this.endpointResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApiResponseOfCreateReactionResult {
    error: boolean;
    message?: string | undefined;
    endpointResult?: CreateReactionResult | undefined;
}

export class CreateReactionResult implements ICreateReactionResult {
    state!: CreateReactionState;
    entityType!: EntityType;
    entityId!: number;
    reaction?: IReaction | undefined;

    constructor(data?: ICreateReactionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.reaction = _data["reaction"] ? IReaction.fromJS(_data["reaction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateReactionResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReactionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["reaction"] = this.reaction ? this.reaction.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateReactionResult {
    state: CreateReactionState;
    entityType: EntityType;
    entityId: number;
    reaction?: IReaction | undefined;
}

export enum CreateReactionState {
    Success = 0,
    ReactionExists = 1,
    BadRequest = 2,
}

export enum EntityType {
    Shout = 0,
    Comment = 1,
}

export abstract class IReaction implements IIReaction {
    id!: number;
    userId!: number;
    reactionTypeId!: number;

    constructor(data?: IIReaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.reactionTypeId = _data["reactionTypeId"];
        }
    }

    static fromJS(data: any): IReaction {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IReaction' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["reactionTypeId"] = this.reactionTypeId;
        return data; 
    }
}

export interface IIReaction {
    id: number;
    userId: number;
    reactionTypeId: number;
}

export class ApiResponseOfCreateCommentResult implements IApiResponseOfCreateCommentResult {
    error!: boolean;
    message?: string | undefined;
    endpointResult?: CreateCommentResult | undefined;

    constructor(data?: IApiResponseOfCreateCommentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.endpointResult = _data["endpointResult"] ? CreateCommentResult.fromJS(_data["endpointResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResponseOfCreateCommentResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCreateCommentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["endpointResult"] = this.endpointResult ? this.endpointResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApiResponseOfCreateCommentResult {
    error: boolean;
    message?: string | undefined;
    endpointResult?: CreateCommentResult | undefined;
}

export class CreateCommentResult implements ICreateCommentResult {
    state!: CreateShoutState;
    newComment?: Comment | undefined;

    constructor(data?: ICreateCommentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.newComment = _data["newComment"] ? Comment.fromJS(_data["newComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCommentResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["newComment"] = this.newComment ? this.newComment.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateCommentResult {
    state: CreateShoutState;
    newComment?: Comment | undefined;
}

export class ApiResponseOfBoolean implements IApiResponseOfBoolean {
    error!: boolean;
    message?: string | undefined;
    endpointResult!: boolean;

    constructor(data?: IApiResponseOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.endpointResult = _data["endpointResult"];
        }
    }

    static fromJS(data: any): ApiResponseOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["endpointResult"] = this.endpointResult;
        return data; 
    }
}

export interface IApiResponseOfBoolean {
    error: boolean;
    message?: string | undefined;
    endpointResult: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}